# StonyGrey.ObjectMapper

StonyGrey.ObjectMapper is a GRPC-aware [source generated](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)
object mapper. In addition to mapping POCOs, it generates extension methods that map between [Protocol Buffers](https://developers.google.com/protocol-buffers) (Protobuf) classes
generated by [Grpc.Tools](https://www.nuget.org/packages/Grpc.Tools/) and domain classes provided by you.

Given a protobuf definition such as this:

```protobuf
package Protobuf;

enum TestEnum { One = 0; Two = 1; }

message TestMessage {
    string String = 1;
    int32 Int = 2;
    optional int32 Optional = 3;
    int32 NonOptional = 4;
    bytes Guid = 5;
    sint64 DateTime = 6;
    oneof OneOf {
        sint64 OneOfA = 7;
        sint64 OneOfB = 8;
    }
    TestEnum TestEnum = 9;
    bytes Data = 10;
    optional bytes OptionalData = 11;
}
```

Grpc.Tools will generate a C# class (that is too verbose in nature to include here).
The StonyGrey.ObjectMapper will generate extension methods <code>MapToProtobuf()</code> and <code>MapFromProtobuf()</code>
that map between this Grpc.Tools created class and a domain class, created by you. For example:

```csharp
namespace Domain
{
    public enum TestEnum { One, Two }

    public class TestMessage
    {
        public string? String { get; set; }
        public int Int { get; set; }
        public int? Optional { get; set; }
        public int NonOptional { get; set; }
        public long OneOfA { get; set; }
        public long OneOfB { get; set; }
        public DateTime DateTime { get; set; }
        public Guid Guid { get; set; }
        public TestEnum TestEnum { get; set; }
        public byte[] Data { get; set; } = Array.Empty<byte>();
        public byte[]? OptionalData { get; set; }
    }
}
```

Extension methods in a class annotated with the <code>MappingConversion</code> attribute will convert between incompatible types.

```csharp
namespace Domain
{
    [MappingConversion]
    public static partial class MappingExtensions
    {
        public static ByteString MapToByteString(this Guid value)
            => ByteString.CopyFrom(value.ToByteArray());

        public static byte[] MapToByteArray(this ByteString value)
            => value == null ? Array.Empty<byte>() : value.ToByteArray();

    ...

    }
}
```

## Usage
Please see the [StonyGrey.ObjectMapper.Host project](https://github.com/stonygrey/StonyGrey.ObjectMapper/tree/main/src/StonyGrey.ObjectMapper.Host) for a working example.

1. Add the [StonyGrey.ObjectMapper Nuget](https://www.nuget.org/packages/StonyGrey.ObjectMapper/) to your project.
1. Use the <code>Map</code> attribute to define the source and target classes:

        [assembly: Map(typeof(Domain.TestMessage), typeof(Protobuf.TestMessage))]
        [assembly: Map(typeof(Protobuf.TestMessage), typeof(Domain.TestMessage), ContainingNamespaceKind.Destination)]
1. Convert incompatible types in a class annotated with <code>MappingConversion</code>.

StonyGrey.ObjectMapper will generate extension methods with the following signatures:

```csharp
public static TargetClass MapFromProtobuf(this SourceClass self) {...}
public static SourceClass MapToProtobuf(this TargetClass self) {...}
```

Have a look under YourProject->Dependencies->Analyzers->StonyGrey.ObjectMapper->StonyGrey.ObjectMapper.MapGenerator



## Mapping
StonyGrey.ObjectMapper was built to address a specific problem and as such does not cover every scenario.
It was tested with [proto3](https://developers.google.com/protocol-buffers/docs/proto3) and [Grpc.Tools 2.45.0](https://www.nuget.org/packages/Grpc.Tools/).

Some additional detail on what is or is not supported follows.

### [Scalars](https://developers.google.com/protocol-buffers/docs/proto3#scalar)
Everything is mapped one-to-one with the exception of <code>bytes</code> which is automatically mapped to/ from <code>Google.Protobuf.ByteString</code>.

### [Enumerations](https://developers.google.com/protocol-buffers/docs/proto3#enum)
Conversion is delegated to the caller but can be as simple as a cast.

### [Other Message Types](https://developers.google.com/protocol-buffers/docs/proto3#other)
Message fields that are themselves messages will need <code>MapProtobuf</code> attributes declared. This allows this library to map an entire object graph.

### [Nested Types](https://developers.google.com/protocol-buffers/docs/proto3#nested)
Untested/ Unsupported.

### [Any](https://developers.google.com/protocol-buffers/docs/proto3#any)
Untested/ Unsupported.

### [Oneof](https://developers.google.com/protocol-buffers/docs/proto3#oneof)
This is supported by relying on the convention that only one of the properties will have a non-default value while all others will have the default value.

### [Maps](https://developers.google.com/protocol-buffers/docs/proto3#maps)
Untested/ Unsupported.

### C# Types
Mapping between properties is attempted in the following order:
1. Simple assignment
2. Conversion using the <code>MappingConversion</code> annotated class.
3. Map()/ MapToProtobuf()/ MapFromProtobuf()

### [Collections/ repeated](https://developers.google.com/protocol-buffers/docs/proto3#specifying_field_rules)
The souce must implement <code>IEumerable<T></code> and the target <code>ICollection<T></code>.

## Acknowledgements

StonyGrey.ObjectMapper is based on the [InlineMapping](https://github.com/JasonBock/InlineMapping) project.
